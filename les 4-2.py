# Задача 4-2. Написать два алгоритма нахождения i-го по счёту простого числа.
# Без использования «Решета Эратосфена»;
# Используя алгоритм «Решето Эратосфена»

import time


def get_simp_num(n):
  """
  Функция для нахождения n-го по счёту простого числа.
  Без использования «Решета Эратосфена»

  """
  simpl_nums = [] # список для хранения  простых чисел
  i = 1 #первое число в списке поиска (не является простым)
  while len(simpl_nums) < n: #пока кол-во найденных простых чисел меньше порядкового номера числа, кот. надо найти
    i += 1 #каждую итерацию берем следующее по порядку число 
    for j in range(2, i+1): #пробуем разделить число i на числе из диапазона от 2 до i
      if j == i: #если делимое и делитель сравнялись, значит число i делится на 1 и на само себя, другие делители нацело не сработали
        simpl_nums.append(i) #добавим делимое в список для хранения  простых чисел
      elif i % j == 0: #если делитель разделил делимое без остатка, число не простое
        break
  return simpl_nums[-1] #вернем последний элемент списка


def get_simp_num_er(n):
  """
  Функция для нахождения n-го по счёту простого числа.
  Используя алгоритм «Решето Эратосфена»
  """
  x = 2   #первое число в списке поиска (является простым)
  simpl_nums = [x] # список для хранения  простых чисел
  while len(simpl_nums) < n: #пока кол-во найденных простых чисел меньше порядкового номера числа, кот. надо найти
    x += 1 #берем следующее по порядку число
    for s in simpl_nums: #перебираем простые числа из хранимого списка уже найденных простых чисел
      if x % s == 0: #если число x получается разделить на найденное простое число без остатка, значит число х не простое
        break #берем следующее число
      elif s == simpl_nums[-1]: # если деление числа х на последнее ранее найденное простое число так же дало остаток, то делимое тоже простое число
        simpl_nums.append(x) #добавим его в список
  return simpl_nums[-1]


# Тестирование:
i=int(input())
start = time.time()
res1 = get_simp_num_er(i)
finish = time.time() - start
print(res1, get_simp_num_er.__doc__, finish)  #->    0.00033020973205566406

start = time.time()
res2 = get_simp_num(i)
finish = time.time() - start
print(res2, get_simp_num.__doc__, finish)  #->    0.0007047653198242188


# Итог: 

  # Функция для нахождения n-го по счёту простого числа.
  # Используя алгоритм «Решето Эратосфена» - сложность алгоритма O(N) (или еще размышляла над этим вариантом: O(N * log N))
  # Без использования «Решета Эратосфена» - сложность алгоритма О(N * M)
  # Время выполнения функции отличается, примерно в 2 раза