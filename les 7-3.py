# Задача7-3. Массив размером 2m + 1, где m – натуральное число, заполнен случайным образом. Найдите в массиве медиану. Медианой называется элемент ряда, делящий его на две равные части: в одной находятся элементы, которые не меньше медианы, в другой – не больше медианы. Задачу можно решить без сортировки исходного массива. Но если это слишком сложно, то используйте метод сортировки, который не рассматривался на уроках


import random


def get_mediana(n, m):    
  """
  Функция, определяющая медиану списка.  На вход получает список n и 
  аргумент m, отображающий длину списка при делении нацело
  
  """
  for i in range(len(n)):
    mediana = n[i]  #  предположим что i-й элемент списка - это медиана
    l, r = [], []    #  первая (не более медианы) и вторая часть(не менее) элементов
    t = [] #   отдельный временный список для хранения элементов одинакового с предполагаемой медианой номинала. Данные элементы в дальнейшем могут быть отнесены как в первую часть, где элементы не более медианы, так и во вторую часть, где не менее
    for j in range(len(n)): # сравним все элементы списка с пердполагаемой медианой
      if i != j: #   исключим сравнение элемента самого с собой
        if n[i] == n[j]: # если элемент равен номиналу медианы, отнесем его временно в список t
          t.append(n[j])
        elif n[i] < n[j] and len(r) < m: # если элемент больше предполагаемой медианы и количество уже отсортированных элементов, значение которых больше медианы, меньше половины всех элементов первоначального списка (нацело)
          r.append(n[j]) # добавим этот j-й элмент в список элементов больше предпол.медианы
        elif n[i] > n[j] and len(l) < m: # если элемент меньше предполагаемой медианы....
          l.append(n[j]) # ...
        else: #  один из списков больше половины всех элементов первоначального списка (нацело)
          break  # переходим к проверке следующего элемента
    if t: # определим, в какой из списков добавить элементы, равные номиналу предполагаемой медианы (данный блок кода будет полезен при поиске медианы в выборках чисел с небольшим диапазоном значений, но при этом со значительным количеством элементов, например [1, 2, 3, 1, 1, 2, 3, 3, 1])
      if len(r)<len(l): #   положим в тот список, который короче
        r.append(t.pop())
      else:
        l.append(t.pop())
    if len(l) == len(r) == m:  # предполагаемая медиана разделила первоначальный список на два равных списка, то это истинная медиана
      return mediana
      

if __name__ == '__main__':
  m = int(input('Введите число: '))
  mas = [random.randint(0, 8) for i in range(2*m + 1)] # сформируем список из 2m+1 элементов
  print(mas)
  mediana = get_mediana(mas, m)
  print(mediana)

# ТЕСТИРОВАНИЕ (при каждом вызове набор чисел mas будет отличаться)
# 1.
  # m = 3, диапазон чисел от 0 до 8
# print(mas)  ->  [3, 5, 2, 8, 5, 8, 1]
# Медиана
# print(mas_sort)  ->  5

# 2
  # m = 5, диапазон чисел от 0 до 8
# print(mas)  ->  [2, 6, 3, 7, 0, 4, 5, 8, 3, 8, 5]
# Медиана
# print(mas_sort)  ->  5
