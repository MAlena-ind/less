# 1. Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков. Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
# Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько вариантов кода для одной и той же задачи. Результаты анализа вставьте в виде комментариев к коду. Также укажите в комментариях версию Python и разрядность вашей ОС.
import sys
import platform

# print(sys.version) # -> Версия Python на платформе repl: 3.8.12
# print(platform.architecture()) # -> на платформе repl ('64bit', '')


# ------- 1-5 -------
# Задача 1-5. Пользователь вводит две буквы. Определить, на каких местах алфавита они стоят и сколько между ними находится букв.
a, b = input().split() 
print(sys.getsizeof(a), sys.getsizeof(b)) # 50 байт + 50 байт
plc_a = ord(a.lower()) - 96
plc_b = ord(b.lower()) - 96
print(sys.getsizeof(plc_a), sys.getsizeof(plc_b))  # 28 байт + 28 байт
betwn = plc_b - plc_a
print(sys.getsizeof(betwn))    # 28 байт
print(f'Буква {a} стоит на {plc_a} месте алфавита.\nБуква {b} стоит на {plc_b} месте.\nМежду ними {abs(betwn)} букв(ы).')
# Для хранения переменных было выделено  184 байт памяти. 
# Мы можем оптимизировать программу, избавившись от некоторых переменных, а именно: 
# хранящих места в алфавите (plc_a и plc_b) и расстояние между буквами (betwn). Закоментируем их и оптимизируем текст вывода
a, b = input().split() 
print(sys.getsizeof(a), sys.getsizeof(b)) # 50 байт + 50 байт
# уберем из программы:
# plc_a = ord(a.lower()) - 96
# plc_b = ord(b.lower()) - 96
# print(sys.getsizeof(plc_a), sys.getsizeof(plc_b))  
# betwn = ord(b.lower()) - ord(a.lower())
# print(sys.getsizeof(betwn))    
print(f'Буква {a} стоит на {ord(a.lower()) - 96} месте алфавита.\nБуква {b} стоит на {ord(b.lower()) - 96} месте.\nМежду ними {abs(ord(b.lower()) - ord(a.lower()))} букв(ы).')
# Вывод: После удаления из программы промежуточных переменных - выделено 100 байт памяти для хранения оставшихся в коде переменных и сокращен общий код программы на 3 строки.


# ------- 2-3 -------
# Задача 2-3. Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран. Например, если введено число 3486, то надо вывести число 6843.

# Решим задачу двумя способами

# 1. Решение при помощи рекурсии
def rev_num(n):
  if len(n) == 0:
      return ''
  else:
    return n[-1] + rev_num(n[:-1])  #-> ~53 * len(n) =  212 байт (4 вызова, каждый храним в памяти во время вызова. n будет меняться от 53 до 50. Берем значение 53 байт)

# 2. Решение при помощи списка
def rev_num_lst(n):
  lst = [None] * len(n) # для избежания релокации создадим заполненный None список для результата
  print(sys.getsizeof(lst))  # -> 88 байт (56 + 8 * 4, 56 - список, по 8 байт каждая ссылка)
  for i in range(len(n)):
    lst[i] = n[-1-i]
  print(sys.getsizeof(lst))  # -> объем занимаемой списком памяти не изменился 88 байт
  return ''.join(lst)
  
x = input() 
print(sys.getsizeof(x))   #-> 4 симовла - 53 байта
print(rev_num(x)) 
print(rev_num_lst(x))

# Данная задача решена двумя способами:
# 1 - с использованием рекурсивной функции (выделено 212 + 53 = 265 байта памяти)
# 2 - используем функцию, заполняющую список (выделено 88 + 53 = 141 байт под переменные)
# Вывод: "выгоднее" использовать программу без рекурсии


# ------- 3-1 -------
# Задача 3-1. В диапазоне натуральных чисел от 2 до 99 определить, сколько из них кратны каждому из чисел в диапазоне от 2 до 9.

n = []
# print(sys.getsizeof(n))  # -> 56 байт (не считаем. Данный список будет поссчитан в своем максимальном размере 120 байт)

for i in range(2, 10):
  # print(sys.getsizeof(i))# -> 28 байт
  x = 0
  # print(sys.getsizeof(x)) # -> 24 байт (x > 0 будет занимать 28 байт. Для расчета считаем 28)
  for j in range(2, 100):
    # print('j= ', sys.getsizeof(j))# -> 28 байт
    if j % i == 0:
      x += 1
  # print(sys.getsizeof([i, x])) #-> 72 байта (56 + 8*2) + i=28 + x=28  (128 байт)
  n.append([i, x])
  # print(sys.getsizeof(n)) # -> изначально 56 / далее 88 / 120 байт (считаем 120 байт)
print(n)
[print(*m, sep='-') for m in n]

# Вывод: 
# n = 120 + x = 28 + i = 28 + j = 28 + ([i, x]=72 * 8 + i=28 * 8 + x=28 * 8) = 1228 байт
# Для переменных суммарно выделено 1228 байт (немного более 1 килобайта)